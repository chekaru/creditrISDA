% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/spread.to.upfront.R
\name{spread.to.upfront}
\alias{spread.to.upfront}
\title{Calculate Upfront Payments}
\usage{
spread.to.upfront(x, currency.var = "currency", notional = 1e+07,
  date.var = "date", spread.var = "spread", coupon.var = "coupon",
  tenor.var = "tenor", maturity.var = "maturity",
  recovery.var = "recovery", isPriceClean = FALSE)
}
\arguments{
\item{x}{data frame, contains all the relevant columns.}

\item{currency.var}{character, column in x containing currency.}

\item{notional}{numeric, the notional amount for all pricing if there isn't a
notional.var}

\item{date.var}{character, column in x containing date variable.}

\item{spread.var}{character, column in x containing spread in basis points.}

\item{coupon.var}{character, column in x containing coupon rates in basis
points. It specifies the payment amount from the protection buyer to the
seller on an annual basis.}

\item{tenor.var}{character, column in x containing tenors.}

\item{maturity.var}{character, column in x containing maturity date.}

\item{recovery.var}{character, column in x containing recovery rates. ISDA
model standard recovery rate asscumption is 0.4.}

\item{isPriceClean}{refers to the type of upfront calculated. It is
       boolean. When \code{TRUE}, calculate principal only. When
       \code{FALSE}, calculate principal + accrual.}

\item{notional.var}{character, column in x containing the amount of the
underlying asset on which the payments are based.}

\item{recovery}{numeric, the recovery rate for all pricing if there isn't a
recovery.var}

\item{notional}{is the amount of the underlying asset on which the
payments are based. Default is 10000000, i.e. 10MM.}

\item{recovery.var}{f column in x containing recovery
rates in decimal.}
}
\value{
vector of upfront values (with accrual) in the same order
}
\description{
\code{spread.to.upfront} takes a dataframe of variables on CDSs to return
a vector of upfront values. Note that all CDS in the data frame must be denominated in
the same currency.
}

